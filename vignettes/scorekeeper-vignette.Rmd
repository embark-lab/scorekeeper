---
title: "A Scorekeeper Vignette"
output: rmarkdown::github_document
vignette: >
  %\VignetteIndexEntry{A Scorekeeper Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The following example depicts how to use the scoresheet package for manipulating data and saving some scored data. This example will use 7 items used to assess binge eating behavior at age 14 in the Avon Longitudinal Study of Parents and Children [ALSPAC](http://www.bristol.ac.uk/alspac/). You can use load this synthetic data and scoresheet in the package to test the example and familiarize yourself with the package. My goal is that building a scoresheet should be an approachable and reproducible process, even for R beginners. While all of this can be accomplished with some savvy dplyr coding, the scoresheet format should harmonize the process, increase approachabiity by reducing the need for heavy coding, allow for easy and reproducable implementation of scoring practices across studies, and offer a useful way to document and disseminate assessment scoring for publication. This package assumes some *very basic* r knowledge (i.e. how to start up r, load packages and data, assign variables, and use basic computations). Some functions require some thoughtful coding, and I try to make that process a bit more approachable via this vignette. I recommend reading the dplyr documentation for an operation if you are stuck on a particular piece of code. 

Ok! Let's get started. First, we load the scorekeeper package: 
```{r setup}
library(scorekeeper)
```

```{r, echo = FALSE}
library(sjmisc)
```

Next, let's familiarize ourselves with the raw data. This example data file includes an `id` variable, 6 binge eating variables (`ccq360`, `ccq370`, `ccq371`, `ccq372`, `ccq373`, `ccq374`, and `ccq375`). I have also included 4 'noisy' variables which are related to other assessments of eating behavior, `ccq380`, `ccq381`, `ccq382` and `ccq383`. 

## Raw Data

```{r, echo=FALSE}
knitr::kable(binge_raw)
```

As you can see from the examples below, these variables are coded in ways that are slightly odd. For instance, `ccq360` is not a descriptive name, and a response of 'never' corresponds to the value of 1. There are also two missing data values currently coded as 'no response' that I'd like to recode as `NA` for analysis. 
```{r}
frq(binge_raw$ccq360)
```

Similarly, you can see that `ccq370` has a 'no' answer coded as a 3, with 'yes, usually' coded as 1 and 'yes, sometimes' coded as a 2. I also see a different missing code pop up here, which is 'not completed'. If I look at the data (and the documentation) I notice that variables ccq370-ccq375 were actually *skipped* if someone answered that they had never binge eaten in question ccq360.  I will also need to recode those variables as 'No' instead of 'not completed' for those variables in order to account for/fill in what the skip logic in the questionnaire missed 


```{r, echo = FALSE}
frq(binge_raw$ccq370)
```
So far, I have identified 4 things that I would like to do to clean these variables prior to analysis: 

**1**. select only `id`, `ccq370`, `ccq371`, `ccq372`, `ccq373`, `ccq374`, and `ccq375` as the variables that I am interested in scoring.

**2**. appropriately account for skip patterns and change entries to 'no' for variables where a skip pattern was employed. 

**3**. recode all negative numbers as 'missing'; recode other responses to be more sensible (e.g. for `ccq370`: 0 = No, 1 = Yes, sometimes, 2 = Yes, usually, OR, if I want to dichotomize these symtpoms, perhaps 0 = No and 1 = Yes - sometimes or usually). 

**4**. rename the variables with more descriptive names. 

## Scoresheet

Currently, your scoresheet should include up to 11 columns which must have names that **exactly** match the following: `raw_vars`, `new_var`, `label`, `operation`, `step`, `val_labs`, `new_vals`, `if_condition`, `if_true_return`, `else_return`, `code`. Not all operations use all columns, so if there is an operation you do not need, you may need fewer columns in your scoresheet. Your scoresheet will still run if you leave out unnecessary columns, but it will give an error if you do not include columns that are needed. 

**Step 0**: I'll just document my raw variables of interest in Step 0, so that anyone who is interested in replicating my scoring can verify that their variables are coded as mine are. This will also give me a starting point to refer back to if I would like to remember how the original varialbes were coded before transformation. For example, see the first three rows (out of 7 variables) below: 

```{r, echo = FALSE}
knitr::kable(binge_scoresheet[1:3,])
```

**Step 1**: I'm going to enter a row in a scoresheet (I use a .csv file with my 11 columns for easy entry and revision, then load it into r using `load_csv`). To select only the variables that I want, I add a row to my scoresheet with `operation` = select and `step` = 1: 
```{r, echo = FALSE}
knitr::kable(binge_scoresheet[8,])
```

Ok! Now for our first test. I'm going to use this row to see if I can select my variables of interest using the scorekeeper package. 
```{r}
#select1 creates a scoreshet tibble with only the 8th row - which contains my 'select' operation that I would like to do in Step 1
select1 <- binge_scoresheet[8,]
#complete the 'scorekeep' function using my raw data and select 1
scorekeep(binge_raw, select1)
```

Great! now the next 



